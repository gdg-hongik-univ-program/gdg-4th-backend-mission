# 캡슐화, 책임을 분명하게 하기
캡슐화는 보통 "데이터나 메소드를 외부에서 접근하지 못하게 막는 것"이라고 표현합니다.  
이것이 왜 중요한지, 어떻게 실현되는지 간단하게 알아볼께요.

현실의 물건을 객체로 옮긴 `Item` 이 있고, 창고인 `Store` 에서 쓰고자 한다고 해봅시다.  
이 `Item` 은 스스로 재고를 관리하고, 구매한 물품 수에 따라 지불해야할 가격을 알려줍니다.  
그렇기 때문에 `Item` 은 재고를 의미하는 `stock` 과 가격을 의미하는 `price` 속성을 가집니다.
```java
    public class Item {
    private int stock;
    private int price;
    
    public void decreaseItem(int quantity) {
        // ....
    } 
    // 구매한 결과에 따른 총액을 반환
    public int totalPrice(int quantity) {
        // ....
    }
}
```

앗, 하지만 `Item` 은 사실 재고 관리와 가격을 반환하는 책임을 가지고 있는게 아니었습니다.  
그저 `Store` 에게 요청받은 구매처리만 해주면 됩니다.  
내부적으로 재고가 줄어들고, 가격을 반환하는 것은 `item` 이 스스로 처리하면 됩니다.  
그렇다면 다음과 같이 다시 작성할 수 있습니다.

```java
    public class Item {
    private int stock;
    private int price;
    
    public int buyItem(int quantity) {
        this.decreaseItem(quantity);
        return this.totalPrice(quantity);
    }
    
    // !! private !!
    private void decreaseItem(int quantity) {
        // ....
    }
    // !! private !!
    // 구매한 결과에 따른 총액을 반환
    private int totalPrice(int quantity) {
        // ....
    }
}
```

`private` 로 함수를 작성함으로서 외부에서 따로 통제할 수 없습니다.  
이를 통해 캡슐화를 지키게 됩니다.  
즉, `buyItem` 함수를 추가함으로서 `Store` 측은 단순히 요청만 하게 됩니다.  
세부적인 구현은 `Store` 는 신경쓰지 않습니다.

이는 `Item` 객체가 내부 로직이 바뀌더라도 `Store` 에 까지 영향을 끼치는 것을 방지해줍니다.  
예컨데, `decreaseItem` 에서 개수에 대한 제한(`quantity` 가 0 이상이어야 함) 을 추가로 체크하더라도,  
`Store` 측의 `buyItem` 호출은 변하지 않습니다.

# Hard Delete Vs Soft Delete
추가 명세 구현과는 약간 별개의 이야기지만, 보편적인 설계에 있어서 중요한 요소이기 때문에 다뤄보려고 합니다.   
데이터베이스에서 데이터를 제거하는 방법은 크게 2가지가 있습니다.  

**Hard Delete**  
데이터베이스 상에서 실제로 제거합니다.  
마치 원래 없던 정보처럼 흔적이 남지 않습니다.  
일반적으로 생각하는 삭제에 해당합니다.

**Soft Delete**  
논리적으로 삭제합니다. 즉, 논리적으로 해당 데이터가 없는 것처럼 생각합니다.  
예를 들어, `activated` 라는 속성을 통해 `false` 라면 삭제인 것처럼 다룹니다.

Soft Delete 가 존재하는 이유는  
삭제된 데이터가 필요한 경우가 있기 때문입니다.  

서비스 운영자 입장에서는 삭제된 데이터가 언제 다시 필요할지 모르는 순간이 있습니다.   
저희의 구현 과제를 예로 들자면,
만약 구매기록을 검색할 때, 현재는 소비자의 이름별로 구분하고 있습니다.    
만약 여기서 "기간별" 이라는 제한이 추가된다고 가정해보겠습니다.  
Hard Delete 를 위해서, User 별로 누적해서 저장했다고 해봅시다.

예를 들어, `A` 유저는 `apple` 을 `5`개, 그리고 그 후에 `6`개를 사서,  
총 `11`개를 산 상황입니다.  

이를 hard delete 를 사용했다면,  
즉, 예약에서 구매로 변했으니 예약기록을 삭제한다면,  
`A, apple, 11` 로 저장했을 겁니다.  

이러한 방식에서는 기간별 제한을 맞출 수 없습니다.  
반면에, `A, apple, 5, 5/23`, `A, apple, 6, 5/26` 같은 방식으로  
2개를 모두 저장했다면 쉽게 처리가 가능합니다.

또한, 소비자가 삭제된 데이터를 기반으로 통계를 내거나, 향후 기획에 활용할 수 있습니다.  
에를 들어, 특정 상품 구매에 대해 비정상적으로 취소 비율이 높다면, 무언가 문제가 있다고 짐작할 수 있습니다.  

궁극적으로는 데이터는 한번 제거하면, 복원할 수 없는 소중한 자산이기 때문입니다.  
저희의 구현 목표인 예약에서도 예약 취소한 이유를 데이터를 통해서 유추해볼 수도 있습니다.
